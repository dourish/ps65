;;;
;;; 6502 Pascal compiler
;;; A basic recursive-descent compiler for a subset of Pascal.
;;; The compiler itself is onne-pass and compiles to p-code; a
;;; separate program executes the p-code (and might clean up
;;; any lingering references in the p-code).
;;;
;;; Written for the Mite 6502 homebrew.
;;;
;;; Paul Dourish, March 2020 (altouhgh based on something
;;; that I intiially wrote in 1985).
;;;


TXTPTR=$80
WORD=$7EC0
SCRATCH=$0010       ; workpad

* = $0300
  jmp start

#include "../mitemon/decl.a65"


;;;
;;; Presume that we enter this code from the FORTH runtime on the Mite.
;;; That means that (1) the upper half of the zero page is reserved
;;; for the stack, (2) X is reserved and already in operation as the
;;; stack pointer, (3) whatever I need for SD card access is available,
;;; annd (4) ACIA annd VIA are already up and running
;;;

;;; CONSTANTS
TK_PROGRAM=1
TK_BEGIN=2
TK_END=3
TK_SEMIC=4
TK_WRITE=5
TK_WRITELN=6
TK_IF=7
TK_THEN=8
TK_ELSE=9
TK_WHILE=10
TK_FOR=11
TK_ASSIGN=12
TK_COLON=13
TK_INTEGER=14
TK_PROCEDURE=15
TK_FUNCTION=16
TK_NUMBER=17
TK_IDENTIFIER=18
TK_BOOLAND=19
TK_BOOLOR=20
TK_BOOLNOT=21
TK_BITAND=22
TK_BITOR=23
TK_BITNOT=24
TK_EQUAL=25
TK_GREATER=26
TK_LESS=27
TK_GREATEREQ=28
TK_LESSEQ=29
TK_NOTEQUAL=30
TK_OPENPAREN=31
TK_CLOSEPAREN=32
TK_CONST=33
TK_VAR=34


;;;
;;; Token table. Each entry is a link field, a token string length,
;;; the token string, and then the token value.
;;;
;;; BUG don't really need the pointer if we know that each entry is
;;; nchars plus two.
;;;
tokentable
.byte 7, "program", TK_PROGRAM
.byte 5, "begin", TK_BEGIN
.byte 3, "end", TK_END
.byte 1, ";", TK_SEMIC
.byte 5, "write", TK_WRITE
.byte 7, "writeln", TK_WRITELN
.byte 2, "if", TK_IF
.byte 4, "then", TK_THEN
.byte 4, "else", TK_ELSE
.byte 5, "while", TK_WHILE
.byte 3, "for", TK_FOR
.byte 2, ":=", TK_ASSIGN
.byte 1, ":", TK_COLON
.byte 7, "integer", TK_INTEGER
.byte 9, "procedure", TK_PROCEDURE
.byte 8, "function", TK_FUNCTION
.byte 3, "and", TK_BOOLAND
.byte 2, "or", TK_BOOLOR
.byte 3, "not", TK_BOOLNOT
.byte 1, "&", TK_BITAND
.byte 1, "|", TK_BITOR
.byte 1, "!", TK_BITNOT
.byte 1, "=", TK_EQUAL
.byte 1, ">", TK_GREATER
.byte 1, "<", TK_LESS
.byte 2, "<=", TK_GREATEREQ
.byte 2, ">=", TK_LESSEQ
.byte 2, "<>", TK_NOTEQUAL
.byte 1, "(", TK_OPENPAREN
.byte 1, ")", TK_CLOSEPAREN
.byte 5, "const", TK_CONST
.byte 3, "var", TK_VAR
.byte 0

;;; ZP locations

;;; other variables




start
  lda #<testbuf
  sta TXTPTR
  lda #>testbuf
  sta TXTPTR+1
nextword
  jsr skipspace
  jsr getword
  jsr findtoken
  jsr putax
  jsr crlf
  bra nextword
  




gettoken



skipspace
.(
  ldy #0
nextchar
  lda (TXTPTR),y
  cmp #32
  beq space
  cmp #8
  beq space
  cmp #10
  beq space
  cmp #13
  beq space
  tya
  beq skip
  clc
  adc TXTPTR
  sta TXTPTR
  bcc skip
  inc TXTPTR+1
skip
  rts
space
  iny
  bra nextchar
.)
  


getword
  lda (TXTPTR)
  ;; is it a number?
  cmp #"0
  bcc notnumber
  cmp #":
  bcs notnumber
  jmp readnumber
  
notnumber
;; is it an alpha?
  cmp #"A
  bcc notalpha
  cmp #"[
  bcc isalpha
  cmp #"a
  bcc notalpha
  cmp #"{
  bcs notalpha
isalpha
  jmp readalphanum

notalpha
  ;; it's a symbol
  sta WORD
  ;; special case for symbols which might be more than one character
  ldy #1
.(
  cmp #".
  bne next
  lda (TXTPTR),y
  cmp #".
  bne finish
  sta WORD,y
  iny
  bra finish
next
.)
.(
  lda (TXTPTR)
  cmp #"<
  bne next
  lda (TXTPTR),y
  cmp #">
  beq second
  cmp #"=
  bne next
second
  sta WORD,y
  iny
  bra finish
next
.)
.(
  lda (TXTPTR)
  cmp #">"
  bne next
  lda (TXTPTR),y
  cmp #"=
  bne next
  sta WORD,y
  iny
  bra finish
next
.)
  cmp #":
  lda (TXTPTR),y
  cmp #"=
  bne finish
  sta WORD,y
  iny
finish
  lda #0
  sta WORD,y
.(
clc
  tya
  beq skip
  adc TXTPTR
  sta TXTPTR
  bcc skip
  inc TXTPTR+1
skip
.)
rts
  

readalphanum
.(
  ldy #0
readnext
  ;; keep on going until we get to a space or a punctuation mark
  ;; other than underscore
  lda (TXTPTR),y
checkupper
  cmp #"A
  bcc checknum
  cmp #"[
  bcc okay
checkunderscore
  cmp #"_
  beq okay
  cmp #"a
  bcc checknum
  cmp #"{
  bcc okay
  bra nope

checknum
  cmp #"0
  bcc nope
  cmp #":
  bcs nope
okay
  sta WORD,y
  iny
  bra readnext

nope
  lda #0
  sta WORD,y
  tya               ; update TXTPTR to point to first non alphanum char
  beq skip
  clc
  adc TXTPTR
  sta TXTPTR
  bcc skip
  inc TXTPTR+1
skip
.)
  rts

readnumber
.(
  ldy #0
nextchar
  lda (TXTPTR),y
  cmp #"0
  bcc nope
  cmp #":
  bcs nope
  sta WORD,y
  iny
  bra nextchar
nope
  lda #0
  sta WORD,y
  clc
  tya
  beq skip
  adc TXTPTR
  sta TXTPTR
  bcc skip
  inc TXTPTR+1
skip
.)
  rts

;;;
;;; Input handling. I need to be able to distinguish lookig at the
;;; current character and consuming it/moving to the next.
;;;

nextchar
.(
;; return next character in buffer, incrementing buffer
  ;; pointer. return NUL if we run off the end of the buffer.
  ;; later, when we do this for real, we'll potentially refill
  ;; the buffer
  lda (TXTPTR)
  pha
  inc TXTPTR
  bne skip
  inc TXTPTR+1
skip
  pla
  rts
.)




thischar
  ;; return character at current pointer
  lda (TXTPTR)
  rts
  

findtoken
  lda #<tokentable  ; SCRATCH/+1 is the pointer to current entry
  sta SCRATCH
  lda #>tokentable
  sta SCRATCH+1

testtoken
  lda (SCRATCH)     ; load character count for this entry
  beq endoftable    ; zero indicates end of table

  sta SCRATCH+4     ; cache the character count

  inc               ; next entry is at base + char count + 2
  inc               ; calculate pointer and store in S+2/3
  clc
  adc SCRATCH       ; cache pointer to next entry
  sta SCRATCH+2
  lda SCRATCH+1
  adc #0
  sta SCRATCH+3
  
.(
  inc SCRATCH       ; move pointer past character count
  bne skip
  inc SCRATCH+1
skip
.)

  ldy #0
testchar
  lda WORD,y
  cmp (SCRATCH),y
  bne matchfail
  iny               ; this char good, so move onto next one
  cpy SCRATCH+4     ; check if we have reached limit
  bne testchar
gotmatch
  lda (SCRATCH),y   ; found match, return the token value
  rts

matchfail
  lda SCRATCH+2     ; match failed so move onto next entry
  sta SCRATCH
  lda SCRATCH+3
  sta SCRATCH+1
  bra testtoken

endoftable
  lda #0
  rts
  

crlf
  lda #10
  jsr ROMPUTA
  lda #13
  jsr ROMPUTA
  rts

putax
.(
  phy

  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  pha             ; put a copy back
  clc
  and #$f0
  ror
  ror
  ror
  ror
  tay
  lda hextable,y
  sta ACIA_DATA
wait_txd_empty2
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty2
  pla
  clc
  and #$0f
  tay
  lda hextable,y
  sta ACIA_DATA
.)
  ply
  rts
hextable:   .byte "0123456789ABCDEF"

ROMPUTA
.(
  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts




testbuf
.byte "   "
.byte "program tprog;"
.byte "var"
.byte "   a :  integer;"
.byte "procedure test;"
.byte "var b : integer;"
.byte "begin"
.byte "   a := 10;"
.byte "   b := 4+3;"
.byte "   writeln(b);"
.byte "   writeln(a);"
.byte "end;"
.byte "begin"
.byte "   test "
.byte "end."
.byte 0
